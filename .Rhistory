# Set population size for dirichlet draws
n_pop_cohort <- 29000
n_pop_trial  <- 272
n_sim <- 10 # just to test function (will be set as n_sim)
df_psa_params_MMS <- generate_psa_params(n_sim = n_sim, seed = 3730687, n_pop = n_pop_trial, scenario = "MMS",
file.death_hr = "data/death_hr.csv",
file.frailty = "data/frailty.csv",
file.weibull = "data/Modified Model Specification/weibull.csv",
file.unconditional = "data/Modified Model Specification/unconditional.csv",
file.overdose = "data/overdose.csv",
file.fentanyl = "data/fentanyl.csv",
file.hiv = "data/hiv_sero.csv",
file.hcv = "data/hcv_sero.csv",
file.costs = "data/Modified Model Specification/costs.csv",
file.crime_costs = "data/Modified Model Specification/crime_costs.csv",
file.qalys = "data/Modified Model Specification/qalys.csv",
file.imis_output = "outputs/Calibration/imis_output.RData")
df_outcomes_MET_PSA_MMS <- data.frame()
df_outcomes_BUP_PSA_MMS <- data.frame()
df_incremental_PSA_MMS <- data.frame()
df_ICER_PSA_MMS <- data.frame()
combine_custom_i <- function(LL1, LL2) {
df_outcomes_MET_PSA_MMS <- rbind(LL1$df_outcomes_MET_PSA_MMS, LL2$df_outcomes_MET_PSA_MMS)
df_outcomes_BUP_PSA_MMS <- rbind(LL1$df_outcomes_BUP_PSA_MMS, LL2$df_outcomes_BUP_PSA_MMS)
df_incremental_PSA_MMS  <- rbind(LL1$df_incremental_PSA_MMS, LL2$df_incremental_PSA_MMS)
df_ICER_PSA_MMS <- rbind(LL1$df_ICER_PSA_MMS, LL2$df_ICER_PSA_MMS)
return(list(df_outcomes_MET_PSA_MMS = df_outcomes_MET_PSA_MMS,
df_outcomes_BUP_PSA_MMS = df_outcomes_BUP_PSA_MMS,
df_incremental_PSA_MMS = df_incremental_PSA_MMS,
df_ICER_PSA_MMS = df_ICER_PSA_MMS))
}
#   df_outcomes_MET_PSA_MMS <- rbind(df_outcomes_MET_PSA_MMS, l_outcomes_MET_MMS$df_outcomes)
#   df_outcomes_BUP_PSA_MMS <- rbind(df_outcomes_BUP_PSA_MMS, l_outcomes_BUP_MMS$df_outcomes)
#
#   # Calculate ICER (societal and health sector perspective)
#   l_ICER_MMS <- ICER(outcomes_comp = l_outcomes_MET_MMS, outcomes_int = l_outcomes_BUP_MMS)
#
#   df_incremental_PSA_MMS <- rbind(df_incremental_PSA_MMS, l_ICER_MMS$df_incremental)
#
#   df_ICER_PSA_MMS <- rbind(df_ICER_PSA_MMS, l_ICER_MMS$df_icer)
# }},
df_model_benchmark_PSA <- microbenchmark("PSA - Multi Core" = {foreach(i = 1:n_sim, .combine = combine_custom_i, .packages = 'tidyr') %dopar% {
# Update parameter set for each scenario with next set of PSA drawn parameters
l_psa_input_MET_MMS <- update_param_list(l_params_all = l_params_MET_MMS, params_updated = df_psa_params_MMS[i, ])
l_psa_input_BUP_MMS <- update_param_list(l_params_all = l_params_BUP_MMS, params_updated = df_psa_params_MMS[i, ])
# Run model and generate outputs
l_outcomes_MET_MMS <- outcomes(l_params_all = l_psa_input_MET_MMS, v_params_calib = v_calib_post_map, PSA = TRUE)
l_outcomes_BUP_MMS <- outcomes(l_params_all = l_psa_input_BUP_MMS, v_params_calib = v_calib_post_map, PSA = TRUE)
# Extract cost and QALY outputs
df_outcomes_MET_PSA_MMS <- l_outcomes_MET_MMS$df_outcomes
df_outcomes_BUP_PSA_MMS <- l_outcomes_BUP_MMS$df_outcomes
# Calculate ICER (societal and health sector perspective)
l_ICER_MMS <- ICER(outcomes_comp = l_outcomes_MET_MMS, outcomes_int = l_outcomes_BUP_MMS)
df_incremental_PSA_MMS <- l_ICER_MMS$df_incremental
df_ICER_PSA_MMS <- l_ICER_MMS$df_icer
return(list(df_outcomes_MET_PSA_MMS = df_outcomes_MET_PSA_MMS,
df_outcomes_BUP_PSA_MMS = df_outcomes_BUP_PSA_MMS,
df_incremental_PSA_MMS = df_incremental_PSA_MMS,
df_ICER_PSA_MMS = df_ICER_PSA_MMS))}},
times = 2)
plot_PSA <- autoplot(df_model_benchmark_PSA)
ggsave(plot_PSA,
filename = "Plots/Benchmark/model_benchmark_PSA.png",
width = 10, height = 7)
stopCluster(cl)
View(df_model_benchmark_PSA)
rstudioapi::restartSession()
rm(list = ls()) # to clean the workspace
library(dplyr)    # to manipulate data
library(reshape2) # to transform data
library(ggplot2)  # for nice looking plots
library(scales)   # for dollar signs and commas
library(dampack)  # for CEA and calculate ICERs
library(tidyverse)
library(rbenchmark)
library(microbenchmark)
library(tictoc)
library(rBeta2009)
library(parallel)
library(foreach)
library(doParallel)
library(tidyr)
# Call model setup functions
source("R/input_parameter_functions.R")
source("R/model_setup_functions.R")
source("R/calibration_functions.R")
source("R/ICER_functions.R")
source("R/generate_psa_parameters.R")
# Load parameters
# Load parameters
source("Analysis/00_load_parameters.R")
# Set number of cores
#n_cores <- detectCores()
#n_cores <- 10
#registerDoParallel(n_cores)
cl <- makeCluster(10)
registerDoParallel(cl)
getDoParRegistered()
# To restart if session fails
#stopCluster(cl)
#rstudioapi::restartSession()
# Benchmark baseline deterministic model
# df_model_benchmark <- microbenchmark("Markov Model (Base)"    = markov_model(l_params_all = l_params_all),
#                                      "Markov Model (Outputs)" = outcomes(l_params_all = l_params_all, v_params_calib = v_calib_post_map),
#                                      times = 100)
# plot <- autoplot(df_model_benchmark)
#
# ggsave(plot,
#        filename = "Plots/Benchmark/model_benchmark.png",
#        width = 10, height = 7)
#
# # Benchmark model calibration
# l_cali_targets <- list(ODF = read.csv(file = "data/cali_target_odf.csv", header = TRUE),
#                        ODN = read.csv(file = "data/cali_target_odn.csv", header = TRUE))
#
# n_cali_max_per <- max(c(l_cali_targets$ODF$Time, l_cali_targets$ODN$Time))
#
# df_model_benchmark_cali <- microbenchmark("Markov Model (Cali)" = markov_model(l_params_all = l_params_all, cali = TRUE), times = 100)
# plot_cali <- autoplot(df_model_benchmark_cali)
#
# ggsave(plot_cali,
#        filename = "Plots/Benchmark/model_benchmark_cali.png",
#        width = 10, height = 7)
# Benchmark PSA
# Set population size for dirichlet draws
n_pop_cohort <- 29000
n_pop_trial  <- 272
n_sim <- 10 # just to test function (will be set as n_sim)
df_psa_params_MMS <- generate_psa_params(n_sim = n_sim, seed = 3730687, n_pop = n_pop_trial, scenario = "MMS",
file.death_hr = "data/death_hr.csv",
file.frailty = "data/frailty.csv",
file.weibull = "data/Modified Model Specification/weibull.csv",
file.unconditional = "data/Modified Model Specification/unconditional.csv",
file.overdose = "data/overdose.csv",
file.fentanyl = "data/fentanyl.csv",
file.hiv = "data/hiv_sero.csv",
file.hcv = "data/hcv_sero.csv",
file.costs = "data/Modified Model Specification/costs.csv",
file.crime_costs = "data/Modified Model Specification/crime_costs.csv",
file.qalys = "data/Modified Model Specification/qalys.csv",
file.imis_output = "outputs/Calibration/imis_output.RData")
df_outcomes_MET_PSA_MMS <- data.frame()
df_outcomes_BUP_PSA_MMS <- data.frame()
df_incremental_PSA_MMS <- data.frame()
df_ICER_PSA_MMS <- data.frame()
combine_custom_i <- function(LL1, LL2) {
df_outcomes_MET_PSA_MMS <- rbind(LL1$df_outcomes_MET_PSA_MMS, LL2$df_outcomes_MET_PSA_MMS)
df_outcomes_BUP_PSA_MMS <- rbind(LL1$df_outcomes_BUP_PSA_MMS, LL2$df_outcomes_BUP_PSA_MMS)
df_incremental_PSA_MMS  <- rbind(LL1$df_incremental_PSA_MMS, LL2$df_incremental_PSA_MMS)
df_ICER_PSA_MMS <- rbind(LL1$df_ICER_PSA_MMS, LL2$df_ICER_PSA_MMS)
return(list(df_outcomes_MET_PSA_MMS = df_outcomes_MET_PSA_MMS,
df_outcomes_BUP_PSA_MMS = df_outcomes_BUP_PSA_MMS,
df_incremental_PSA_MMS = df_incremental_PSA_MMS,
df_ICER_PSA_MMS = df_ICER_PSA_MMS))
}
#df_model_benchmark_PSA <- microbenchmark("PSA - Single Core" = {for (i in 1:n_sim){
#   # Update parameter set for each scenario with next set of PSA drawn parameters
#   l_psa_input_MET_MMS <- update_param_list(l_params_all = l_params_MET_MMS, params_updated = df_psa_params_MMS[i, ])
#   l_psa_input_BUP_MMS <- update_param_list(l_params_all = l_params_BUP_MMS, params_updated = df_psa_params_MMS[i, ])
#
#   # Run model and generate outputs
#   l_outcomes_MET_MMS <- outcomes(l_params_all = l_psa_input_MET_MMS, v_params_calib = v_calib_post_map, PSA = TRUE)
#   l_outcomes_BUP_MMS <- outcomes(l_params_all = l_psa_input_BUP_MMS, v_params_calib = v_calib_post_map, PSA = TRUE)
#
#   # Extract cost and QALY outputs
#   df_outcomes_MET_PSA_MMS <- rbind(df_outcomes_MET_PSA_MMS, l_outcomes_MET_MMS$df_outcomes)
#   df_outcomes_BUP_PSA_MMS <- rbind(df_outcomes_BUP_PSA_MMS, l_outcomes_BUP_MMS$df_outcomes)
#
#   # Calculate ICER (societal and health sector perspective)
#   l_ICER_MMS <- ICER(outcomes_comp = l_outcomes_MET_MMS, outcomes_int = l_outcomes_BUP_MMS)
#
#   df_incremental_PSA_MMS <- rbind(df_incremental_PSA_MMS, l_ICER_MMS$df_incremental)
#
#   df_ICER_PSA_MMS <- rbind(df_ICER_PSA_MMS, l_ICER_MMS$df_icer)
# }},
df_model_benchmark_PSA <- microbenchmark("PSA - Multi Core" = {foreach(i = 1:n_sim, .combine = combine_custom_i, .packages = 'tidyr') %dopar% {
# Update parameter set for each scenario with next set of PSA drawn parameters
l_psa_input_MET_MMS <- update_param_list(l_params_all = l_params_MET_MMS, params_updated = df_psa_params_MMS[i, ])
l_psa_input_BUP_MMS <- update_param_list(l_params_all = l_params_BUP_MMS, params_updated = df_psa_params_MMS[i, ])
# Run model and generate outputs
l_outcomes_MET_MMS <- outcomes(l_params_all = l_psa_input_MET_MMS, v_params_calib = v_calib_post_map, PSA = TRUE)
l_outcomes_BUP_MMS <- outcomes(l_params_all = l_psa_input_BUP_MMS, v_params_calib = v_calib_post_map, PSA = TRUE)
# Extract cost and QALY outputs
df_outcomes_MET_PSA_MMS <- l_outcomes_MET_MMS$df_outcomes
df_outcomes_BUP_PSA_MMS <- l_outcomes_BUP_MMS$df_outcomes
# Calculate ICER (societal and health sector perspective)
l_ICER_MMS <- ICER(outcomes_comp = l_outcomes_MET_MMS, outcomes_int = l_outcomes_BUP_MMS)
df_incremental_PSA_MMS <- l_ICER_MMS$df_incremental
df_ICER_PSA_MMS <- l_ICER_MMS$df_icer
return(list(df_outcomes_MET_PSA_MMS = df_outcomes_MET_PSA_MMS,
df_outcomes_BUP_PSA_MMS = df_outcomes_BUP_PSA_MMS,
df_incremental_PSA_MMS = df_incremental_PSA_MMS,
df_ICER_PSA_MMS = df_ICER_PSA_MMS))}},
times = 2)
plot_PSA <- autoplot(df_model_benchmark_PSA)
ggsave(plot_PSA,
filename = "Plots/Benchmark/model_benchmark_PSA.png",
width = 10, height = 7)
stopCluster(cl)
rm(list = ls()) # to clean the workspace
library(dplyr)    # to manipulate data
library(reshape2) # to transform data
library(ggplot2)  # for nice looking plots
library(scales)   # for dollar signs and commas
library(dampack)  # for CEA and calculate ICERs
library(tidyverse)
library(rbenchmark)
library(microbenchmark)
library(tictoc)
library(rBeta2009)
library(parallel)
library(foreach)
library(doParallel)
library(tidyr)
# Call model setup functions
source("R/input_parameter_functions.R")
source("R/model_setup_functions.R")
source("R/calibration_functions.R")
source("R/ICER_functions.R")
source("R/generate_psa_parameters.R")
# Load parameters
# Load parameters
source("Analysis/00_load_parameters.R")
# Set number of cores
#n_cores <- detectCores()
#n_cores <- 10
#registerDoParallel(n_cores)
cl <- makeCluster(10)
registerDoParallel(cl)
getDoParRegistered()
# To restart if session fails
#stopCluster(cl)
#rstudioapi::restartSession()
# Benchmark baseline deterministic model
# df_model_benchmark <- microbenchmark("Markov Model (Base)"    = markov_model(l_params_all = l_params_all),
#                                      "Markov Model (Outputs)" = outcomes(l_params_all = l_params_all, v_params_calib = v_calib_post_map),
#                                      times = 100)
# plot <- autoplot(df_model_benchmark)
#
# ggsave(plot,
#        filename = "Plots/Benchmark/model_benchmark.png",
#        width = 10, height = 7)
#
# # Benchmark model calibration
# l_cali_targets <- list(ODF = read.csv(file = "data/cali_target_odf.csv", header = TRUE),
#                        ODN = read.csv(file = "data/cali_target_odn.csv", header = TRUE))
#
# n_cali_max_per <- max(c(l_cali_targets$ODF$Time, l_cali_targets$ODN$Time))
#
# df_model_benchmark_cali <- microbenchmark("Markov Model (Cali)" = markov_model(l_params_all = l_params_all, cali = TRUE), times = 100)
# plot_cali <- autoplot(df_model_benchmark_cali)
#
# ggsave(plot_cali,
#        filename = "Plots/Benchmark/model_benchmark_cali.png",
#        width = 10, height = 7)
# Benchmark PSA
# Set population size for dirichlet draws
n_pop_cohort <- 29000
n_pop_trial  <- 272
n_sim <- 100 # just to test function (will be set as n_sim)
df_psa_params_MMS <- generate_psa_params(n_sim = n_sim, seed = 3730687, n_pop = n_pop_trial, scenario = "MMS",
file.death_hr = "data/death_hr.csv",
file.frailty = "data/frailty.csv",
file.weibull = "data/Modified Model Specification/weibull.csv",
file.unconditional = "data/Modified Model Specification/unconditional.csv",
file.overdose = "data/overdose.csv",
file.fentanyl = "data/fentanyl.csv",
file.hiv = "data/hiv_sero.csv",
file.hcv = "data/hcv_sero.csv",
file.costs = "data/Modified Model Specification/costs.csv",
file.crime_costs = "data/Modified Model Specification/crime_costs.csv",
file.qalys = "data/Modified Model Specification/qalys.csv",
file.imis_output = "outputs/Calibration/imis_output.RData")
df_outcomes_MET_PSA_MMS <- data.frame()
df_outcomes_BUP_PSA_MMS <- data.frame()
df_incremental_PSA_MMS <- data.frame()
df_ICER_PSA_MMS <- data.frame()
combine_custom_i <- function(LL1, LL2) {
df_outcomes_MET_PSA_MMS <- rbind(LL1$df_outcomes_MET_PSA_MMS, LL2$df_outcomes_MET_PSA_MMS)
df_outcomes_BUP_PSA_MMS <- rbind(LL1$df_outcomes_BUP_PSA_MMS, LL2$df_outcomes_BUP_PSA_MMS)
df_incremental_PSA_MMS  <- rbind(LL1$df_incremental_PSA_MMS, LL2$df_incremental_PSA_MMS)
df_ICER_PSA_MMS <- rbind(LL1$df_ICER_PSA_MMS, LL2$df_ICER_PSA_MMS)
return(list(df_outcomes_MET_PSA_MMS = df_outcomes_MET_PSA_MMS,
df_outcomes_BUP_PSA_MMS = df_outcomes_BUP_PSA_MMS,
df_incremental_PSA_MMS = df_incremental_PSA_MMS,
df_ICER_PSA_MMS = df_ICER_PSA_MMS))
}
#df_model_benchmark_PSA <- microbenchmark("PSA - Single Core" = {for (i in 1:n_sim){
#   # Update parameter set for each scenario with next set of PSA drawn parameters
#   l_psa_input_MET_MMS <- update_param_list(l_params_all = l_params_MET_MMS, params_updated = df_psa_params_MMS[i, ])
#   l_psa_input_BUP_MMS <- update_param_list(l_params_all = l_params_BUP_MMS, params_updated = df_psa_params_MMS[i, ])
#
#   # Run model and generate outputs
#   l_outcomes_MET_MMS <- outcomes(l_params_all = l_psa_input_MET_MMS, v_params_calib = v_calib_post_map, PSA = TRUE)
#   l_outcomes_BUP_MMS <- outcomes(l_params_all = l_psa_input_BUP_MMS, v_params_calib = v_calib_post_map, PSA = TRUE)
#
#   # Extract cost and QALY outputs
#   df_outcomes_MET_PSA_MMS <- rbind(df_outcomes_MET_PSA_MMS, l_outcomes_MET_MMS$df_outcomes)
#   df_outcomes_BUP_PSA_MMS <- rbind(df_outcomes_BUP_PSA_MMS, l_outcomes_BUP_MMS$df_outcomes)
#
#   # Calculate ICER (societal and health sector perspective)
#   l_ICER_MMS <- ICER(outcomes_comp = l_outcomes_MET_MMS, outcomes_int = l_outcomes_BUP_MMS)
#
#   df_incremental_PSA_MMS <- rbind(df_incremental_PSA_MMS, l_ICER_MMS$df_incremental)
#
#   df_ICER_PSA_MMS <- rbind(df_ICER_PSA_MMS, l_ICER_MMS$df_icer)
# }},
df_model_benchmark_PSA <- microbenchmark("PSA - Multi Core" = {foreach(i = 1:n_sim, .combine = combine_custom_i, .packages = 'tidyr') %dopar% {
# Update parameter set for each scenario with next set of PSA drawn parameters
l_psa_input_MET_MMS <- update_param_list(l_params_all = l_params_MET_MMS, params_updated = df_psa_params_MMS[i, ])
l_psa_input_BUP_MMS <- update_param_list(l_params_all = l_params_BUP_MMS, params_updated = df_psa_params_MMS[i, ])
# Run model and generate outputs
l_outcomes_MET_MMS <- outcomes(l_params_all = l_psa_input_MET_MMS, v_params_calib = v_calib_post_map, PSA = TRUE)
l_outcomes_BUP_MMS <- outcomes(l_params_all = l_psa_input_BUP_MMS, v_params_calib = v_calib_post_map, PSA = TRUE)
# Extract cost and QALY outputs
df_outcomes_MET_PSA_MMS <- l_outcomes_MET_MMS$df_outcomes
df_outcomes_BUP_PSA_MMS <- l_outcomes_BUP_MMS$df_outcomes
# Calculate ICER (societal and health sector perspective)
l_ICER_MMS <- ICER(outcomes_comp = l_outcomes_MET_MMS, outcomes_int = l_outcomes_BUP_MMS)
df_incremental_PSA_MMS <- l_ICER_MMS$df_incremental
df_ICER_PSA_MMS <- l_ICER_MMS$df_icer
return(list(df_outcomes_MET_PSA_MMS = df_outcomes_MET_PSA_MMS,
df_outcomes_BUP_PSA_MMS = df_outcomes_BUP_PSA_MMS,
df_incremental_PSA_MMS = df_incremental_PSA_MMS,
df_ICER_PSA_MMS = df_ICER_PSA_MMS))}},
times = 2)
plot_PSA <- autoplot(df_model_benchmark_PSA)
ggsave(plot_PSA,
filename = "Plots/Benchmark/model_benchmark_PSA.png",
width = 10, height = 7)
stopCluster(cl)
getDoParRegistered()
stopCluster(cl)
cl <- makeCluster(14)
registerDoParallel(cl)
getDoParRegistered()
# Set number of cores
n_cores <- detectCores() - 1
stopCluster(cl)
cl <- makeCluster(10)
registerDoParallel(cl)
getDoParRegistered()
df_model_benchmark_PSA_10 <- microbenchmark("PSA - Multi Core (10 cores)" = {foreach(i = 1:n_sim, .combine = combine_custom_i, .packages = 'tidyr') %dopar% {
# Update parameter set for each scenario with next set of PSA drawn parameters
l_psa_input_MET_MMS <- update_param_list(l_params_all = l_params_MET_MMS, params_updated = df_psa_params_MMS[i, ])
l_psa_input_BUP_MMS <- update_param_list(l_params_all = l_params_BUP_MMS, params_updated = df_psa_params_MMS[i, ])
# Run model and generate outputs
l_outcomes_MET_MMS <- outcomes(l_params_all = l_psa_input_MET_MMS, v_params_calib = v_calib_post_map, PSA = TRUE)
l_outcomes_BUP_MMS <- outcomes(l_params_all = l_psa_input_BUP_MMS, v_params_calib = v_calib_post_map, PSA = TRUE)
# Extract cost and QALY outputs
df_outcomes_MET_PSA_MMS <- l_outcomes_MET_MMS$df_outcomes
df_outcomes_BUP_PSA_MMS <- l_outcomes_BUP_MMS$df_outcomes
# Calculate ICER (societal and health sector perspective)
l_ICER_MMS <- ICER(outcomes_comp = l_outcomes_MET_MMS, outcomes_int = l_outcomes_BUP_MMS)
df_incremental_PSA_MMS <- l_ICER_MMS$df_incremental
df_ICER_PSA_MMS <- l_ICER_MMS$df_icer
return(list(df_outcomes_MET_PSA_MMS = df_outcomes_MET_PSA_MMS,
df_outcomes_BUP_PSA_MMS = df_outcomes_BUP_PSA_MMS,
df_incremental_PSA_MMS = df_incremental_PSA_MMS,
df_ICER_PSA_MMS = df_ICER_PSA_MMS))}},
times = 2)
rm(list = ls()) # to clean the workspace
library(dplyr)    # to manipulate data
library(reshape2) # to transform data
library(ggplot2)  # for nice looking plots
library(scales)   # for dollar signs and commas
library(dampack)  # for CEA and calculate ICERs
library(tidyverse)
library(rbenchmark)
library(microbenchmark)
library(tictoc)
library(rBeta2009)
library(parallel)
library(foreach)
library(doParallel)
library(tidyr)
# Call model setup functions
source("R/input_parameter_functions.R")
source("R/model_setup_functions.R")
source("R/calibration_functions.R")
source("R/ICER_functions.R")
source("R/generate_psa_parameters.R")
# Load parameters
# Load parameters
source("Analysis/00_load_parameters.R")
# Set number of cores
n_cores <- detectCores() - 1
# Benchmark PSA
# Set population size for dirichlet draws
n_pop_cohort <- 29000
n_pop_trial  <- 272
n_sim <- 100 # just to test function (will be set as n_sim)
df_psa_params_MMS <- generate_psa_params(n_sim = n_sim, seed = 3730687, n_pop = n_pop_trial, scenario = "MMS",
file.death_hr = "data/death_hr.csv",
file.frailty = "data/frailty.csv",
file.weibull = "data/Modified Model Specification/weibull.csv",
file.unconditional = "data/Modified Model Specification/unconditional.csv",
file.overdose = "data/overdose.csv",
file.fentanyl = "data/fentanyl.csv",
file.hiv = "data/hiv_sero.csv",
file.hcv = "data/hcv_sero.csv",
file.costs = "data/Modified Model Specification/costs.csv",
file.crime_costs = "data/Modified Model Specification/crime_costs.csv",
file.qalys = "data/Modified Model Specification/qalys.csv",
file.imis_output = "outputs/Calibration/imis_output.RData")
df_outcomes_MET_PSA_MMS <- data.frame()
df_outcomes_BUP_PSA_MMS <- data.frame()
df_incremental_PSA_MMS <- data.frame()
df_ICER_PSA_MMS <- data.frame()
combine_custom_i <- function(LL1, LL2) {
df_outcomes_MET_PSA_MMS <- rbind(LL1$df_outcomes_MET_PSA_MMS, LL2$df_outcomes_MET_PSA_MMS)
df_outcomes_BUP_PSA_MMS <- rbind(LL1$df_outcomes_BUP_PSA_MMS, LL2$df_outcomes_BUP_PSA_MMS)
df_incremental_PSA_MMS  <- rbind(LL1$df_incremental_PSA_MMS, LL2$df_incremental_PSA_MMS)
df_ICER_PSA_MMS <- rbind(LL1$df_ICER_PSA_MMS, LL2$df_ICER_PSA_MMS)
return(list(df_outcomes_MET_PSA_MMS = df_outcomes_MET_PSA_MMS,
df_outcomes_BUP_PSA_MMS = df_outcomes_BUP_PSA_MMS,
df_incremental_PSA_MMS = df_incremental_PSA_MMS,
df_ICER_PSA_MMS = df_ICER_PSA_MMS))
}
cl <- makeCluster(10)
registerDoParallel(cl)
getDoParRegistered()
df_model_benchmark_PSA_10 <- microbenchmark("PSA - Multi Core (10 cores)" = {foreach(i = 1:n_sim, .combine = combine_custom_i, .packages = 'tidyr') %dopar% {
# Update parameter set for each scenario with next set of PSA drawn parameters
l_psa_input_MET_MMS <- update_param_list(l_params_all = l_params_MET_MMS, params_updated = df_psa_params_MMS[i, ])
l_psa_input_BUP_MMS <- update_param_list(l_params_all = l_params_BUP_MMS, params_updated = df_psa_params_MMS[i, ])
# Run model and generate outputs
l_outcomes_MET_MMS <- outcomes(l_params_all = l_psa_input_MET_MMS, v_params_calib = v_calib_post_map, PSA = TRUE)
l_outcomes_BUP_MMS <- outcomes(l_params_all = l_psa_input_BUP_MMS, v_params_calib = v_calib_post_map, PSA = TRUE)
# Extract cost and QALY outputs
df_outcomes_MET_PSA_MMS <- l_outcomes_MET_MMS$df_outcomes
df_outcomes_BUP_PSA_MMS <- l_outcomes_BUP_MMS$df_outcomes
# Calculate ICER (societal and health sector perspective)
l_ICER_MMS <- ICER(outcomes_comp = l_outcomes_MET_MMS, outcomes_int = l_outcomes_BUP_MMS)
df_incremental_PSA_MMS <- l_ICER_MMS$df_incremental
df_ICER_PSA_MMS <- l_ICER_MMS$df_icer
return(list(df_outcomes_MET_PSA_MMS = df_outcomes_MET_PSA_MMS,
df_outcomes_BUP_PSA_MMS = df_outcomes_BUP_PSA_MMS,
df_incremental_PSA_MMS = df_incremental_PSA_MMS,
df_ICER_PSA_MMS = df_ICER_PSA_MMS))}},
times = 2)
rm(list = ls()) # to clean the workspace
library(dplyr)    # to manipulate data
library(reshape2) # to transform data
library(ggplot2)  # for nice looking plots
library(tidyverse)
library(rBeta2009)
library(parallel)
library(foreach)
library(doParallel)
library(tidyr)
# Call model setup functions
# To-do: Move into package eventually
source("R/input_parameter_functions.R")
source("R/generate_psa_parameters.R")
source("R/model_setup_functions.R")
source("R/ICER_functions.R")
# Load parameters
source("Analysis/00_load_parameters.R")
### Process PSA results
## Read-in saved results
## Modified Model Specification
load(file = "outputs/PSA/Modified Model Specification/outcomes_MET_PSA_MMS.RData")
load(file = "outputs/PSA/Modified Model Specification/outcomes_BUP_PSA_MMS.RData")
load(file = "outputs/PSA/Modified Model Specification/incremental_PSA_MMS.RData")
load(file = "outputs/PSA/Modified Model Specification/ICER_PSA_MMS.RData")
#####################
### Plot ellipses ###
#####################
### Societal perspective ###
# MMS
df_incremental_PSA_MMS_TOTAL_6mo <- df_incremental_PSA_MMS_comb %>% as_tibble() %>% mutate(inc_qalys_MMS_6mo = n_inc_qalys_TOTAL_6mo,
inc_costs_MMS_6mo = n_inc_costs_TOTAL_6mo) %>% select(inc_qalys_MMS_6mo, inc_costs_MMS_6mo)
df_incremental_PSA_MMS_TOTAL_life <- df_incremental_PSA_MMS_comb %>% as_tibble() %>% mutate(inc_qalys_MMS_life = n_inc_qalys_TOTAL_life,
inc_costs_MMS_life = n_inc_costs_TOTAL_life) %>% select(inc_qalys_MMS_life, inc_costs_MMS_life)
# Combine
df_PSA_ellipse_TOTAL <- cbind(df_incremental_PSA_MMS_TOTAL_6mo, df_incremental_PSA_MMS_TOTAL_life)
df_PSA_ellipse_TOTAL <- df_PSA_ellipse_TOTAL %>% mutate(Scenario = "Societal Perspective")
### Health sector perspective ###
# MMS
df_incremental_PSA_MMS_HEALTH_SECTOR_6mo <- df_incremental_PSA_MMS_comb %>% as_tibble() %>% mutate(inc_qalys_MMS_6mo = n_inc_qalys_TOTAL_6mo,
inc_costs_MMS_6mo = n_inc_costs_HEALTH_SECTOR_6mo) %>% select(inc_qalys_MMS_6mo, inc_costs_MMS_6mo)
df_incremental_PSA_MMS_HEALTH_SECTOR_life <- df_incremental_PSA_MMS_comb %>% as_tibble() %>% mutate(inc_qalys_MMS_life = n_inc_qalys_TOTAL_life,
inc_costs_MMS_life = n_inc_costs_HEALTH_SECTOR_life) %>% select(inc_qalys_MMS_life, inc_costs_MMS_life)
# Combine
df_PSA_ellipse_HEALTH_SECTOR <- cbind(df_incremental_PSA_MMS_HEALTH_SECTOR_6mo, df_incremental_PSA_MMS_HEALTH_SECTOR_life)
df_PSA_ellipse_HEALTH_SECTOR <- df_PSA_ellipse_HEALTH_SECTOR %>% mutate(Scenario = "Health Sector Perspective")
# Combine all
df_PSA_ellipse <- rbind(df_PSA_ellipse_TOTAL, df_PSA_ellipse_HEALTH_SECTOR)
df_PSA_points_temp <- df_PSA_ellipse %>% as_tibble() %>% rename(qalys.6mo = inc_qalys_MMS_6mo,
qalys.life = inc_qalys_MMS_life,
costs.6mo = inc_costs_MMS_6mo,
costs.life = inc_costs_MMS_life) %>% mutate(ID = row_number())
df_PSA_points_qalys <- df_PSA_points_temp %>% select(ID, Scenario, qalys.6mo, qalys.life)
df_PSA_points_qalys_long <- reshape(df_PSA_points_qalys, direction = 'long',
varying = c('qalys.6mo', 'qalys.life'),
timevar = 'var',
times = c('6mo', 'life'),
v.names = 'qalys',
idvar = c('ID', 'Scenario'))
df_PSA_points_costs <- df_PSA_points_temp %>% select(ID, Scenario, costs.6mo, costs.life)
df_PSA_points_costs_long <- reshape(df_PSA_points_costs, direction = 'long',
varying = c('costs.6mo', 'costs.life'),
timevar = 'var',
times = c('6mo', 'life'),
v.names = 'costs',
idvar = c('ID', 'Scenario'))
df_PSA_points <- bind_cols(df_PSA_points_qalys_long, df_PSA_points_costs_long, .name_repair = "minimal")
df_PSA_points <- inner_join(df_PSA_points_qalys_long, df_PSA_points_costs_long, by = c('ID', 'var', 'Scenario')) %>%
mutate(index = ifelse(Scenario == "Societal Perspective" & var == "6mo", "Societal (6-month)",
ifelse(Scenario == "Societal Perspective" & var == "life", "Societal (Lifetime)",
ifelse (Scenario == "Health Sector Perspective" & var == "6mo", "Health Sector (6-month)", "Health Sector (Lifetime)"))))
